Getting Started
~~~~~~~~~~~~~~

Building RESTful API Service
===========================

== 목차
..... *<<intro>>*

..... *<<main1>>*
        <<section1-1>>::
        
        <<section1-2>>::

..... *<<main2>>*
        <<section2-1>>::
			<<section2-1-1>>

        <<section2-2>>::
            <<section2-2-1>> +
            <<section2-2-2>> +
			<<section2-2-3>> +
			<<section2-2-4>> +
			<<section2-2-5>> +
			<<section2-2-6>>

        <<section2-3>>::
            <<section2-3-1>> +
            <<section2-3-2>> +
            <<section2-3-3>>

        <<section2-4>>::
            <<section2-4-1>> +
            <<section2-4-2>> +
			<<section2-4-3>> +
			<<section2-4-4>>

..... *<<outro>>*


// Page 구분
<<<



[[intro]]
== Introduce
*Spring Boot 기반의 link:http://spring.io/understanding/REST[REST] API 서비스 구축을 위한 레퍼런스 문서입니다.*

NOTE: RESTful API 설계 가이드는 link:설계가이드url[RESTful API 설계 가이드]를 참조 바랍니다.

=== Features
* link:https://www.w3.org/TR/cors[CORS(Cross-Origin Resource Sharing)]를 위한 해결책이 있습니다.
* 사용자 인증을 위해 link:http://oauth.net/2/[Oauth2.0] Client로써의 API Service를 구축합니다.

=== Need
* 약 15분의 시간
* Maven 3.0+
* java 7+
* IDE


// Page 구분
<<<


[[main1]]
== Add on REST API Service
Spring Boot를 사용하여 손쉽게 API 서비스를 구축해 보겠습니다.


[[section1-1]]
=== 1. API 서비스 개발하기2
* 본 섹션에서는 API 서비스가 가져야하는 필수 기능들에 대해 다루겠습니다.
* 기능 특성에 따라 일부는 본 가이드에서 분리되어 독립적으로 제공됩니다.


[[section2-4-1]]
==== 4.(1) 에러 처리하기

===== 4.(1).1) Http Status Code
* 에러를 다루기 이전에 RESTful 하게 주요 HTTP 상태코드에 대해서 알아보겠습니다.
* API의 응답코드로 사용될만한 코드를 중심으로 소개하겠습니다.

.link:https://en.wikipedia.org/wiki/List_of_HTTP_status_codes[HTTP Status Code]
|===
|Code|Message |Description
|200 |OK(성공) |서버가 요청을 제대로 처리
|201 |Created(작성됨) |성공적으로 요청되었으며 서버가 새 리소스를 작성했다.
|204 |No Content(컨텐츠 없음) |서버가 요청을 성공적으로 처리했지만 콘텐츠를 제공하지 않는다.
|301 |Moved Permanently(영구 이동) |요청한 페이지를 새 위치로 영구적으로 이동했다. GET 또는 HEAD 요청에 대한 응답으로 이 응답을 표시하면 요청자가 자동으로 새 위치로 전달된다.
|400 |Bad Request(잘못된 요청) |서버가 요청의 구문을 인식하지 못했다.
|401 |Unauthorized(권한 없음) |이 요청은 인증이 필요하다. 서버는 로그인이 필요한 페이지에 대해 이 요청을 제공할 수 있다.
|404 |Not Found(찾을 수 없음) |서버가 요청한 컨텐츠를 찾을 수 없다.
|409 |Conflict(충돌) |서버가 요청을 수행하는 중에 충돌이 발생했다. 서버는 응답할 때 충돌에 대한 정보를 포함해야 한다. 서버는 PUT 요청과 충돌하는 PUT 요청에 대한 응답으로 이 코드를 요청 간 차이점 목록과 함께 표시해야 한다.
|410 |Gone(사라짐) |서버는 요청한 리소스가 영구적으로 삭제되었을 때 이 응답을 표시한다. 404(찾을 수 없음) 코드와 비슷하며 이전에 있었지만 더 이상 존재하지 않는 리소스에 대해 404 대신 사용하기도 한다. 리소스가 영구적으로 이동된 경우 301을 사용하여 리소스의 새 위치를 지정해야 한다.
|500 |Internal Server Error(내부 서버 오류) |서버에 오류가 발생하여 요청을 수행할 수 없다.
|===
NOTE: link:http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml[공식사이트]의 상세 Spec을 통해 상황에 따라 적합한 상태코드를 찾아보세요.


===== 4.(1).2) Business Exception 설계

[NOTE]
====
Business Exception 설계는 API 설계 시 완료되어야 하는 부분이지만, +
가이드 문서 편의상 지금 진행하겠습니다. +
참고: Sample Project의 <<api_list>>
====

* 여러 상황에 대해 오류처리가 가능하지만
* Sample Project인 만큼 간편하게 케이스를 다루겠습니다.

.오류 발생 상황
회원가입 시 admin이라는 loginName으로 등록 경우 LoginName 중복 오류 발생

* *POST /user*
* Exception: *DuplicateLoginNameException*
* HTTP Staus Code: *209 Conflict*
* Response:
[source, json]
{
   "timestamp": 1453350197105,
   "status": 209,
   "error": "Duplicate loginName value",
   "errorCode": "TEST0001"
   "exception": "DuplicateLoginNameException"
}

===== 4.(1).3) ExceptionHandler 등록
[NOTE]
====
아래의 내용은 Spring 3.x 이하의 버전의 ExceptionHandler와 동일한 기능을 수행합니다. +
하지만 사용하는 방법에 있어 차이가 있을 수 있습니다.
====

.UserController.class
[source, java]
----
// 생략
@ExceptionHandler(DuplicateLoginNameException.class)
@ResponseStatus(value = HttpStatus.CONFLICT, reason = "Duplicate loginName value")
public void duplicateLoginName() {
    logger.error("[DuplicateLoginNameException] - LoginName is already in use.");
}
// 생략
----

===== 4.(1).4) DuplicateLoginNameException Class 생성

.DuplicateLoginNameException.class
[source, java]
----
package org.anyframe.cloud.rest.application.exception;

public class DuplicateLoginNameException extends RuntimeException {
}
----
.. application package 하위에 exception package에 생성합니다.
.. 추가적으로 구현할 기능요건이 없으므로 *_RuntimeException_* 만 상속합니다.

NOTE: Exception Class 생성 시 패키지나, 부모클래스, 구현내용 등은 솔루션 표준에 의거 작성하면 됩니다.

===== 4.(1).5) Business Logic 추가

.UserServiceImpl.class
[source, java]
----
// 생략
@Override
public User registerUser(User newUser) {
    logger.info("$$$ registerUser - new user : ".concat(newUser.toString()));

    if("admin".equals(newUser.getLoginName())){
        throw new DuplicateLoginNameException();
    }

    newUser.setId("GeneratedID");

    User registeredUser = newUser;
    logger.info("$$$ registerUser - registered user : ".concat(registeredUser.toString()));

    return registeredUser;
}
// 생략
----
.. DuplicateLoginNameException 발생을 위해 "admin"과 비교하는 if문을 작성합니다.

===== 4.(1).6) 오류처리 테스트

. 서버를 구동합니다.(<<run_app>>)
. curl 호출 방식을 통해 회원가입(POST /user) 요청

.curl 요청
[source, Shell]
----
curl -X POST http://localhost:8081/user \
-H "Content-Type: application/json" \
-d '{"loginName":"admin","emailAddress":"cloud@api.com","firstName":"cloud","lastName":"anyframe"}'
----

.Response Body
[source, Json]
----
{
  "timestamp": 1453361729003,
  "status": 409,
  "error": "Conflict",
  "exception": "org.anyframe.cloud.rest.application.exception.DuplicateLoginNameException",
  "message": "Duplicate loginName value",
  "path": "/user"
}
----
[NOTE]
====
오류처리에 대한 응답 메시지가 설계와 다른 모습을 볼 수가 있습니다. +
Spring Boot Web Starter에 의해 기본 메시지 타입이 사용됐기 때문입니다.
====

[TIP]
====
.Spring Boot의 Default 오류처리
. 처리하는 Controller
 * org.springframework.boot.autoconfigure.web.BasicErrorController
. ResponseEntity 항목 구성
 * org.springframework.boot.autoconfigure.web.DefaultErrorAttributes
====



===== 4.(1).7) Error Type Customizing

* 최초 설계하였던 오류메시지 형식에 맞도록 Customizing 해보겠습니다.

.Custom Error Type Class 생성하기
[source, Java]
----
package org.anyframe.cloud.rest.interfaces.dto;

import java.util.Date;

public class SampleError {

    private Date timestamp;

    private int status;

    private String errorCode;

    private String error;

    private String exception;

    public SampleError() {
    }

    public SampleError(Date timestamp, int status, String errorCode, String error, String exception) {
        this.timestamp = timestamp;
        this.status = status;
        this.errorCode = errorCode;
        this.error = error;
        this.exception = exception;
    }

    public Date getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(Date timestamp) {
        this.timestamp = timestamp;
    }

    public int getStatus() {
        return status;
    }

    public void setStatus(int status) {
        this.status = status;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }

    public String getError() {
        return error;
    }

    public void setError(String error) {
        this.error = error;
    }

    public String getException() {
        return exception;
    }

    public void setException(String exception) {
        this.exception = exception;
    }
}
----

.ControllerAdvice 생성하기
[source, Java]
----
package org.anyframe.cloud.restservice.controller.rest;

import org.anyframe.cloud.restservice.service.exception.DuplicateLoginNameException;
import org.anyframe.cloud.restservice.controller.dto.SampleError;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import javax.servlet.http.HttpServletRequest;
import java.util.Date;

@ControllerAdvice(basePackageClasses  = UserController.class)
public class UserControllerAdvice extends ResponseEntityExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(UserControllerAdvice.class);


    @ExceptionHandler(DuplicateLoginNameException.class)
    @ResponseBody
    ResponseEntity<?> duplicateLoginName(HttpServletRequest request, Throwable ex) {

        logger.error("[DuplicateLoginNameException] - LoginName is already in use.");

        HttpStatus status = HttpStatus.valueOf(409);

        return new ResponseEntity<>(
                new SampleError(new Date()
                    , status.value()
                    , "TEST00001"
                    , ex.getMessage()
                    , ex.getClass().getSimpleName())
                , HttpStatus.valueOf(409));
    }
}
----
. 기존에 UserController에 있던 @ExceptionHandler 메소드를 삭제합니다.
. @ControllerAdvice Class 생성
.. 일반적으로 모든 @RequestMapping 방법에 적용되는 @ExceptionHandler, @InitBinder, 및 @ModelAttribute 방법을 정의하는데 사용됩니다.
. @ExceptionHandler 메소드 구현
.. ResponseEntityExceptionHandler를 상속하고 메소드에 @ResponseBody를 추가함으로써 Exception 처리 후 BasicErrorController를 거치지 않고 응답합니다.

[TIP]
====
@ControllerAdvice 대신 오류 메시지 타입을 재정의하는 또 다른 방법으로는 BasicErrorController를 상속하는 방법이 있습니다.
====

===== 4.(1).8) 오류처리 테스트

. 서버를 구동합니다.(<<run_app>>)
. curl 호출 방식을 통해 회원가입(POST /user) 요청

.curl 요청
[source, Shell]
----
curl -X POST http://localhost:8081/user \
-H "Content-Type: application/json" \
-d '{"loginName":"admin","emailAddress":"cloud@api.com","firstName":"cloud","lastName":"anyframe"}'
----

.Response Body
[source, Json]
----
{
  "timestamp": 1453438312522,
  "status": 409,
  "errorCode": "TEST00001",
  "error": "dup",
  "exception": "DuplicateLoginNameException"
}
----
NOTE: 응답 메시지 타입이 변경된 것을 확인할 수 있습니다.

[[section2-4-2]]
==== 4.(2) CORS(Cross-Origin Resource Sharing)

[[section2-4-3]]
==== 4.(3) Seal으로 보안 강화하기

[[section2-4-4]]
==== 4.(4) OAuth 2.0 클라이언트로서의 API Service

[[section2-4-5]]
==== 4.(5) ??



// Page 구분
<<<


[[outro]]
== Summary
굉장히 간단한 Spring Boot 기반의 RESTfull API Service 구축을 실습했습니다. +
link:./doc/consuming_a_restful_api_with_angularjs2.adoc[다음 가이드]에서는 API 클라이언트로써 간단한 UI Application 개발을 실습해보도록 하겠습니다.

[NOTE]
.아직 가이드에 추가되지 않은 내용입니다.
====
* Security
* Oauth2.0
====